---
title: "demCorrFunc"
author: "JSC"
date: "1/30/2019"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

## Packages

```{r}

library(stringr)
library(car)
library(leaps)
library(lubridate)
library(rvest)
library(olsrr)
library(corrplot)
library(leaps)
library(pdftools)
library(magick)
library(tesseract)
library(plm)
library(httr)
library(textreadr)
library(foreign)
library(plm)
library(bea.R)
library(dplyr)
library(tidyr)
library(ggplot2)
library(clusterSEs)
#source("http://www.reuningscherer.net/s&ds230/Rfuncs/regJDRS.txt")
library(RCurl)
library(clubSandwich)
library(multiwayvcov)
library(ppcor)
library(psych)
library(data.table)

```

## Working directory

```{r}

# prompts for setting working directoryn

# e.g. my working directory path: /Users/jcarlson/Dropbox (Yale Law School)/democracy_work

working_directory <- as.character(readline("enter working directory path: "))

setwd(working_directory)
getwd()

```


## Functions

```{r}

# potentially useful function for converting from iso abbreviation to country name
iso_em <- read.csv("data_directory/iso_em.csv", as.is = T, header = F)

iso_convert <- function(x) {
  iso_em[which(grepl(x, iso_em$V2)),][,1]
}

# get lagging differences for single variable and add it back to dataframe
lags_for_indicator <- function(ind, df, rStart, rEnd) {
  tempdf <- eval(parse(text = df))
  for (i in rStart:rEnd) {
    nametemp <- paste0(as.character(ind), "_lag_", as.character(i))
    tempdf <- tempdf %>% group_by(country_name) %>% 
      mutate_(.dots=setNames(
        list(quote(
        eval(parse(text = ind))  - dplyr::lag(eval(parse(text = ind)), n=i, order_by = year)
        )), nametemp))
  }
  return(tempdf)
}

# get lagging differences for multiple variables and add it back to dataframe
lags_for_indicatorS <- function(inds, df, rStart, rEnd) {
  tempdf <- eval(parse(text = df))
  for (ind in inds) {
    for (i in rStart:rEnd) {
      nametemp <- paste0(as.character(ind), "_lag_", as.character(i))
      tempdf <- tempdf %>% group_by(country_name) %>% 
      mutate_(.dots=setNames(
        list(quote(
        eval(parse(text = ind))  - dplyr::lag(eval(parse(text = ind)), n=i, order_by = year)
        )), nametemp))
    }
  }
  return(tempdf)
}

# get leading differences for single variable and add it back to dataframe
leads_for_indicator <- function(ind, df, rStart, rEnd) {
  tempdf <- eval(parse(text = df))
  for (i in rStart:rEnd) {
    nametemp <- paste0(as.character(ind), "_lead_", as.character(i))
    tempdf <- tempdf %>% group_by_("GeoAreaName") %>% 
      mutate_(.dots=setNames(list(quote(dplyr::lead(eval(parse(text = ind)), n=i, order_by = year) - eval(parse(text = ind)))), nametemp))
  }
  return(tempdf)
}

# get leading differences for multiple variables and add it back to dataframe
leads_for_indicatorS <- function(inds, df, rStart, rEnd) {
  tempdf <- eval(parse(text = df))
  for (ind in inds) {
    for (i in rStart:rEnd) {
      nametemp <- paste0(as.character(ind), "_lead_", as.character(i))
      tempdf <- tempdf %>% group_by_("country") %>% 
        mutate_(.dots=setNames(
        list(quote(
        dplyr::lead(eval(parse(text = ind)), n=i, order_by = year) - eval(parse(text = ind))
        )), nametemp))
    }
  }
  return(tempdf)
}

# primary plotting function
getPlots <- function(indDF, newDFcountryCol, newDFyearCol, newDFvarCol, leadstart, leadend) {
  
  leadIndDF <- leads_for_indicatorS(newDFvarCol, indDF, leadstart, leadend)
  mergedDF <- merge(vDataRelLags, leadIndDF, by.x = c("country_name", "year"), by.y = c(newDFcountryCol, newDFyearCol))
  relVLab <- c("v2x_libdem", "v2x_rule", "v2x_regime", "v2x_partipdem", "v2x_freexp", "v2x_civlib", "v2xps_party", "v2xcs_ccsi")

  corrTable <- rep(NA, 6)
  
  for (i in leadstart:leadend) {
    for (j in 1:50) {
      for (k in 1:8) {
        for (l in 1:length(newDFvarCol)) {
          lagpartlabel <- paste0("mergedDF$", relVLab[k], "_lag_", j)
          leadpartlabel <- paste0("mergedDF$", newDFvarCol[l], "_lead_", i)
          
          tryCatch({
            corResults <- cor.test(
            eval(parse(text = lagpartlabel)), 
            eval(parse(text = leadpartlabel)))
            corrTable <- rbind(corrTable, c(k, j, i, corResults$estimate, corResults$p.value, corResults$parameter))
          }, error=function(e){print(i)})
        }
      }
    }
  }
  
  corrTable <- as.data.frame(corrTable)
  corrTable <- corrTable[-1,]
  names(corrTable) <- c("var", "lag", "lead", "estimate", "pvalue", "degf")
  rownames(corrTable) <- NULL
  print(head(corrTable))

  for (m in 1:8) {

    print(ggplot(corrTable[corrTable$var==m,], aes(x=lag, y=estimate))  +
      geom_line(aes(color=factor(lead))) +
      geom_point(aes(fill=factor(pvalue<=0.05)), size=2, shape=21, stroke=0) +
      scale_fill_manual(values=c("#FF0000", "#000000")) + 
      ylab("correlation estimate") + 
      xlab(paste(relVLab[m], "lagged diffs")) +
      labs(fill="Significant\nat p=0.05?", colour=paste0(newDFvarCol,"\nleading\ndiffs")))
      
  }

  return(corrTable)

}

longest_seq <- function(x) {
  s <- split(x, cumsum(c(TRUE, diff(x) != 1)))
  s[[which.max(lengths(s))]]
}

longest_seq_df <- function(frame) {
  dt <- data.table(frame)
  dt <- dt[, longest_seq(year), by = country]
  names(dt) <- c("country", "year")
  df <- data.frame(dt)
  return(merge(frame, df))
}
  
```

## Data

```{r}

# permanent storage of V-Dem data (which takes a long time to reload in the event it becomes mucked up)
vDataPerm <- read.csv("data_directory/V-Dem-CY+Others-v8.csv", as.is = T)

```

```{r}

# clean data from V-Dem
vData <- vDataPerm

vDataRelevant <- vData[,c("country_name", "country_text_id", "year", "v2x_libdem", "v2x_rule", "v2x_regime", "v2x_partipdem", "v2x_freexp", "v2x_civlib", "v2xps_party", "v2xcs_ccsi")]

vDataRelLags <- lags_for_indicatorS(c("v2x_libdem", "v2x_rule", "v2x_regime", "v2x_partipdem", "v2x_freexp", "v2x_civlib", "v2xps_party", "v2xcs_ccsi"), "vDataRelevant", 1, 50)

# get data for EPI
epiData <- read.csv("data_directory/epi20072016.csv", as.is = T)[,-1]
epiData2 <- read.csv("data_directory/epi2016.csv", as.is = T)
epiData <- merge(epiData2, epiData)
t_epiData <- data.frame(t(epiData), stringsAsFactors = F)
t_epiData <- cbind(rownames(t_epiData), t_epiData)
rownames(t_epiData) <- NULL
names(t_epiData) <- t_epiData[1,]
epiData <- t_epiData[-1,]
rownames(epiData) <- NULL
epiData <- epiData %>% gather(key = "country", value = "epiScore", -1)
names(epiData) <- c("year", "country", "epiScore")
epiData$year <- as.integer(gsub("current", "2018", gsub("EPI\\.", "", epiData$year)))
epiData$epiScore <- as.numeric(epiData$epiScore)

# get data for SDG 1.1.1 indicator
sdg1_ind <- read.csv("data_directory/sdg1_1_1_longform.csv")
names(sdg1_ind) <- c("country", "year", "pctPovLvl")
rownames(sdg1_ind) <- NULL
sdg1_ind <- longest_seq_df(sdg1_ind)

# check completeness of indicators
table(sdg1_ind$country)
mean(table(sdg1_ind$country))
na.omit(leads_for_indicatorS("pctPovLvl", "sdg1_ind", 5, 12)[,1:4])

# this one is important: this dataframe is the best indication of how complete the indicator is--it includes
# only those countries with a continuous sequence of over 8 years of data
sdg1MoreThan8 <- data.frame(table(sdg1_ind$country) >= 8)
sdg1MoreThan8$country <- rownames(sdg1MoreThan8)
rownames(sdg1MoreThan8) <- NULL
names(sdg1MoreThan8)[1] <- "moreThan8"
sdg1_ind_over8 <- sdg1_ind[merge(sdg1_ind, sdg1MoreThan8)$moreThan8,]


```

# Run It!

```{r}

# getPlots(name of dataframe (DF) of interest, what that DF calls the country index, what that DF calls the year index, what that DF calls the indicator of interset, the range of year leads to calculate differences for)

# e.g. for the plots in the earlier write-up: getPlots("epiData", "country", "year", "epiScore", 6, 9)

getPlots("sdg1_ind_over8", "country", "year", "pctPovLvl", 5, 10)
getPlots("epiData", "country", "year", "epiScore", 6, 9)


```





